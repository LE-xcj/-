进程调度，就是绪状态的进程获得 CPU 的使用权，进程由就绪状态转变成运行状态。

进程调度可以分为：

抢占式 系统会根据进程的优先级高低来进行调度，进程之间可以插队
非抢占式 系统按照先来先服务的方式来调度，进程间不能插队

进程调度算法有很多，比较常用的调度算法如下：

![](https://mmbiz.qpic.cn/mmbiz_png/BWLbK9PgqK2pVAwXbx1JQGibzDmKefJibpp3su2ibxo6gs8Qrkic6MhWK0mMLkmdXicqApTvKkC5Sm0Bvela4gGWb2Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**1、先来先服务 first come first serve （FCFS）**

先来的进程先被调度，这种算法很公平，但是如果执行的是一个长作业，那么后面的短作业将会被长时间搁置，造成短作业饥饿。

**2、短作业优先 shortest job first （SJF）**

为了避免短作业饥饿的情况，就优先把短作业都执行完，然后再执行长作业。这样又会引发另一个问题，那就是如果短作业非常多，那么容易导致长作业将不会被执行，又会造成长作业饥饿。

**3、时间片轮转 round serve （RS）**

时间片轮转就是轮询，定义一个时间片的长度，然后平均给每个进程分配时间片，一旦时间片用完，此时作业未执行完，作业就会从运行状态转变成就绪状态，等待被重新调度。如果作业比较多，那这样容易造成长作业需要轮转好久才能执行完。

**4、多级反馈队列**

该算法设置了不同的队列，可以分类为高、中、低优先级队列，并且优先级越高，分配的时间片就越短，反之优先级越低，分配时间片越长。首先，先进来的作业会进入高优先级；如果没有被执行完，就会压入中优先级队列；如果还没执行完再压入低优先级队列。只有上一个队列的进程被执行完，才能执行当前队列的进程。

这种算法还是无法有效避免长作业饥饿的情况，因为只有高优先级队列没有进程，才会执行下一级别的队列。假如上一级的队列一直有进程，那么下一级别的队列的进程将会饥饿。

**5、高响应比优先**

这种算法是在短作业优先调度算法的基础上，加上一个随着时间累计而叠加的权重机制。

系统会根据优先级来决定进程执行的先后，但同时为了确保那些等待时间长的进程也能被执行，那么就会结合进程等待的时间来更新进程的权重。其中等待时间越长，那么权重越高。

这种算法既可以优先完成短作业，又能确保长作业不至于长期饥饿，是一个折中的算法。